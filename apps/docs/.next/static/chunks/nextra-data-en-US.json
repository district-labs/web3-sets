{"/runtime/evm/inputs":{"title":"EVM Runtime Inputs","data":{"":"The EVM runtime accepts a single RuntimeSeed argument.\ntype RuntimeSeed = {\nset: EVMSet\nstate: EVMStateArtifacts\nclients: Client[]\nargs: RuntimeArguments\n}\n\nconst runtimeSeed: RuntimeSeed = {...}\nconst analysis = runtime(runtimeSeed)\nA RuntimeSeed object has 4 fields: 2 required and 2 semi-optional.\nEVMSet: A set marked as set:evm containing EVM entity references, conditions and rules.\nEVMStateArtifacts: EVM state artifacts like transactions, logs and storage proofs.\nClients: JSON-RPC provider client connections with read and archive_read support.\nRuntimeArguments: Dynamic inputs for operation and observation arguments.\n\nThe EVMSet and EVMStateArtifacts fields are always required to execute the runtime.The Client and RuntimeArguments are only required if the Set expects the runtime to handle read and archive_read operations and includes dynamic operation and/or includes dynamic operation and observation arguments.","how-it-works#How It Works":"Basic Runtime ExampleThe minimum arguments required to execute the runtime is a set and state artifacts.\nruntime({\nset,\nartifacts\n})\nAdvanced Runtime Example\nFor sets that require reads and archive_read functionality a JSON-RPC provider client is required.If a set has dynamic arguments the runtime will also require the arguments are passed during the runtime.\nruntime({\nset,\nartifacts: {\n\"logs\": Log[],\n\"proofs\": Proof[],\n\"receipts\": Receipt[],\n\"transactions\": Transaction[],\n}\nclients: Client[],\nargs: {\nINJECT_VALUE: \"0x0000000000000000000000000000000000000000\"\n}\n})","set-required#Set (Required)":"{\nid: \"set:pooltogether:10:usdc:prize-pool:deposit\",\nobject: \"set:evm\",\nname: \"PoolTogether $10 USDC Deposit\",\ndescription: \"Deposit $10 USDC into the PoolTogether V4 PrizePool on the Optimism network\",\nkeywords: [\"pooltogether\", \"optimism\", \"usdc\"],\nversion: {\nmajor: 0,\nminor: 0,\npatch: 0\n},\nentities: [\n{\nchainId: 10,\naddress: \"0x79bc8bd53244bc8a9c8c27509a2d573650a83373\",\nabi: \"ipfs://Qmc6MHybup7ppGgUdyEcsi5jqCeTAPtcxF9wBaco56Uc1H\",\nname: \"PoolTogether USDC Prize Pool\"\n}\n],\nconditions: [\n{\nid: \"condition:0x79bc8bd53244bc8a9c8c27509a2d573650a83373:depositTo:gte:100000000\",\neid: \"0x79bc8bd53244bc8a9c8c27509a2d573650a83373\",\nname: \"PoolTogether Optimism Deposit over 1 USDC\",\ntype: \"transaction\",\nsignature: \"depositTo(address,uint256)\",\nvalues: [\n{\nindex: 1,\ncondition: \"gte\",\nvalue: \"10000000\"\n}\n]\n}\n],\nrules: [\n{\nid: \"rule.complete\",\noperations: [\"all\"],\nargs: [[\"condition:0x79bc8bd53244bc8a9c8c27509a2d573650a83373:depositTo:gte:100000000\"]]\n}\n]\n}","artifacts-required#Artifacts (Required)":"{\nlogs: Log[],\nproofs: Proof[]\nreceipts: Receipts[]\ntransactions: Transaction[]\n}","clients-optional#Clients (Optional)":"For a Javascript runtime we recommend using the viem client interface.For a Rust runtime we don't recommend a specific crate. Dealers choice.","arguments-optional#Arguments (Optional)":"Arguments can be used to provide operation and observation inputs during runtime.For example we might have a condition that is intended to measure \"burning\" a token. In most cases we could hard code the 0x0 address, but there might times when a custom address is desired and we don't want to create a new set.For these instances we can use arguments to hydrate set condition and rule operation arguments, before comparing the set to state artifacts.\n// runtime arguments\n{\nADDRESS_BURN: \"0x0000000000000000000000000000000000000000\"\n}\n\n// condition with dynamic observation argument\n{\nid: \"condition:transfer:to\",\neid: \"0x7ea2be2df7ba6e54b1a9c70676f668455e329d29\",\ntype: \"transaction\",\nsignature: \"transfer(address,uint256)\",\nvalues: [\n{\nindex: 0,\ncondition: \"eq\",\nvalue: \"$ADDRESS_BURN\"\n},\n]\n}\n\nconst analysis = runtime({\nset: Set_With_Dynamic_Arguments,\nartifacts: Artifacts,\nargs: {\nADDRESS_BURN: \"0x0000000000000000000000000000000000000000\"\n}\n})"}},"/overview/set-theory":{"title":"Set Theory","data":{"":"Web3 Sets derives it's approach from naive set theory\nSet theory is the branch of mathematical logic that studies sets, which can be informally described as collections of objects. Although objects of any kind can be collected into a set, set theory, as a branch of mathematics, is mostly concerned with those that are relevant to mathematics as a whole.A naive theory in the sense of \"naive set theory\" is a non-formalized theory, that is, a theory that uses natural language to describe sets and operations on sets. The words and, or, if ... then, not, for some, for every are treated as in ordinary mathematics.In naive set theory, a set is described as a well-defined collection of objects. These objects are called the elements or members of the set. Objects can be anything: numbers, people, other sets, etc.\nWeb3 Sets views every resource in the Web3 Universe as an Entity i.e. object.\nSmart Contracts\nVerifiable Credentials\nDecentralized Identifiers\netc...\n\nEntities always have measurable behaviors and properties i.e. cryptographically provable inputs and outputs.For example the PoolTogether V4 USDC Prize Pool on Optimism deployed at the 0x79bc8bd53244bc8a9c8c27509a2d573650a83373 address is an immutable smart contract -- it will always behave in a predictable and measurable way. Producting EVM state artifacts like  transactions, logs and storage proofs, when the Entity is interacted with.We can use EVM state artifacts to cryptographically verify the behavior the PT:V4:PrizePool:USDC:Optimism Entity and compare to a Set that describes a specific set of properties we care about.Quantifying the behaviors of individual entities in the Web3 Universe means we can begin to create sets that describe complex, multi-environment behaviors achieved through a summation of individual Entity properties i.e. cryptographically verifiable input and output mutations grouped together to generate high-order operations and primitives.Web Sets, in sense are describing \"complex digital organisms\" using low-level cryptographic primitives.It's human directed evolution. But for the digital organisms."}},"/overview/use-cases":{"title":"Use Cases","data":{"":"The use case for Web3 Sets is broad. And that's because a rules engine for the Web3 universe is applicable to a variety of products.Web3 Set runtimes can be used stand-alone with other runtimes. For example the EVM Web3 Set schema can be used to power a transaction recommendation engine.\nOr it can be used in combination with the Identity Web3 Set runtime to build a multi-environment access control gateway.A low-level rules engine for Web3 primitives has multiple use cases.\nTransaction Recommendation Engine\nSelective Disclosure Request Standards\nMulti-Environment Access Control Gateways\n\nIt's all about what problem you want to solve. But in almost all cases a map of the world will help you."}}}